#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <stdlib.h>

int main()
{
    time_t* cur_time = (time_t*)malloc(sizeof(time_t));

    time(cur_time);
    printf("Current Time = %d\n", (int)*cur_time);

    char *cur_string;

    cur_string = ctime(cur_time);
    printf("Current Time String = %s\n", cur_string);

    return (0);
}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(void)
{
	char *homedir, filename[80];
	FILE *fp;
	
	homedir = getenv("HOME");
	strcpy(filename, homedir);
	strcat(filename, "/test.log");

	if((fp=fopen(filename, "w")) == NULL) {
		perror("fopen");
		exit(1);
	}

	fwrite("getenv test\n", 12, 1, fp);
	fclose(fp);
	return (0);
}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    int fd = 3;

    if(write(fd, "hello", 5) == -1) {
        perror("write");
        exit(1);
    }

    close(fd);
    return (0);
}#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <stdlib.h>

int main(void)
{
    time_t* cur_time = (time_t*)malloc(sizeof(time_t));

    time(cur_time);
    printf("Current Time = %d\n", (int) *cur_time);

    return 0;
}       #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    int fd;
    fd = open("mypipe", O_RDONLY);
    if(fd == -1){
        perror("open");
        exit(1);
    }
    char buf[512];
    int n;
    for(int i=0; i<5; i++) {
        n = read(fd, buf, sizeof(buf));
        buf[n]='\0';
        printf("from send > %s\n", buf);
    }
    sleep(1);
    close(fd);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    int fd;
    fd = open("mypipe", O_WRONLY);
    if(fd == -1){
        perror("open");
        exit(1);
    }
    char buf[] = "hello pipe";
    for(int i=0; i<5; i++) {
        write(fd, buf, strlen(buf));
    }
    sleep(3);
    close(fd);
}
#include <stdio.h>
#include <unistd.h>
#include <sys/msg.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int msgid;
    struct msgbuf {
        long mtype;
        char mtext[1014];
    } mbuf;

    msgid = msgget(ftok("/home/ubuntu", 100), IPC_CREAT | 0666);
    if(msgid==-1) {
        perror("msgget");
        exit(1);
    }

    if(msgrcv(msgid, &mbuf, sizeof(mbuf), 1, 0)<0) {
        printf("error\n");
        exit(1);
    }
    sleep(5);
    msgctl(msgid, IPC_RMID, 0);
}
#include <stdio.h>
#include <unistd.h>
#include <sys/msg.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int msgid;
    struct msgbuf {
        long mtype;
        char mtext[1014];
    } mbuf;

    msgid = msgget(ftok("/home/ubuntu", 100), IPC_CREAT | 0666);
    if(msgid==-1) {
        perror("msgget");
        exit(1);
    }
    mbuf.mtype = 1;
    strcpy(mbuf.mtext, "sender");
    msgsnd(msgid, &mbuf, sizeof(mbuf),0);
    // msgctl(msgid, IPC_RMID, 0);
}
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

void cd_func(char** arg);

struct b_cmd{
    char *cmd;
    void (*func)(char**);
} builtin_cmd[] = {
    {"cd", cd_func},
    {NULL, NULL}
};


int is_builtin(char** arg)
{
    for(int i=0; builtin_cmd[i].cmd!=NULL; i++) {
        if(strcmp(arg[0], builtin_cmd[i].cmd)==0) {
            builtin_cmd[i].func(arg);
            return 1;
        }
    }
    return 0;
}

void cd_func(char** arg)
{
    if(chdir(arg[1])==1) {
        perror("chdir");
        return;
    }
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char** command_parse(char *line) {
  	int argcount = 0;
  	char * token;
  	char **arglist;

  	if (line == NULL) {
    	return NULL;
  	}

  	if ((token=strtok(line," \t\n")) == NULL) {
    	return NULL;
  	}

  	arglist=(char **)malloc(sizeof(char *));

  	while (token != NULL) {
    	arglist[argcount++]=strdup(token);
    	token=strtok(NULL, " \t\n");
    	arglist=(char **)realloc(arglist, (argcount+1)*sizeof(char *));
  	}

  	arglist[argcount] = NULL;
  	return arglist;
}


void command_freelist(char **arglist) {

  int i;

  for (i = 0; arglist[i] != NULL; i++) {
    free(arglist[i]);
  }
  free(arglist);
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>

int is_background(char** arglist);
int redirect_out(char** arglist);
int run_command(char** arglist);

int run_command(char** arglist) {
    pid_t cpid;
    int back_flag = 0;

    if (is_background(arglist))
        back_flag = 1;

    for (int i = 0; arglist[i] != NULL; i++) {
        if (strcmp(arglist[i], "|") == 0) {
            arglist[i] = NULL; // 현재 명령어 종료
            int pipefd[2];
            if (pipe(pipefd) == -1) {
                perror("pipe");
                return -1;
            }

            pid_t pid2 = fork();
            if (pid2 == -1) {
                perror("fork");
                return -1;
            } else if (pid2 == 0) { // 첫 번째 명령어 실행
                close(pipefd[0]);
                dup2(pipefd[1], STDOUT_FILENO);
                close(pipefd[1]);
                execvp(arglist[0], arglist);
                perror("execvp");
                exit(1);
            } else { // 두 번째 명령어 실행
                close(pipefd[1]);
                dup2(pipefd[0], STDIN_FILENO);
                close(pipefd[0]);
                execvp(arglist[i + 1], &arglist[i + 1]);
                perror("execvp");
                exit(1);
            }
        } else if (strcmp(arglist[i], ">") == 0) {
            if (redirect_out(arglist) == -1) {
                return -1;
            }
        }
    }

    // 기본 명령어 실행
    cpid = fork();
    if (cpid == -1) {
        perror("fork");
        return -1;
    }

    if (cpid == 0) { // 자식 프로세스
